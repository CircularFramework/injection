{"version":3,"sources":["../../src/classes/injection-engine.class.js"],"names":["InjectionEngine","dependencies","token","item","dependency","push","find","d","dependent","tokens","args","length","forEach","dependencyRef","get","instance","isSingleton","construct","concat"],"mappings":";;;;;;;qjBAAA;;;AACA;;;;;;AAEA;;;;IAIMA,e;AACL,4BAAc;AAAA;;AACb;AACA,OAAKC,YAAL,GAAoB,EAApB;AACA;;AAED;;;;;;;;;;uBAMKC,K,EAAOC,I,EAAM;AACjB;AACA,OAAIC,aAAa,2BAAeF,KAAf,EAAsBC,IAAtB,CAAjB;AACA,QAAKF,YAAL,CAAkBI,IAAlB,CAAuBD,UAAvB;AACA,UAAOA,UAAP;AACA;;AAED;;;;;;;;sBAKIF,K,EAAO;AACV,UAAO,KAAKD,YAAL,CAAkBK,IAAlB,CAAuB;AAAA,WAAKC,EAAEL,KAAF,KAAYA,KAAjB;AAAA,IAAvB,CAAP;AACA;;AAED;;;;;;;;;4BAMUM,S,EAAmC;AAAA;;AAAA,OAAxBC,MAAwB,uEAAf,EAAe;AAAA,OAAXC,IAAW,uEAAJ,EAAI;;AAC5C;AACA,OAAIT,eAAe,EAAnB;AACA,OAAIQ,OAAOE,MAAP,GAAgB,CAApB,EAAuB;AACtBF,WAAOG,OAAP,CAAe,iBAAS;AACvB;AACA,SAAIC,gBAAgB,MAAKC,GAAL,CAASZ,KAAT,CAApB;;AAEA;AACA,SAAIE,aAAaS,cAAcE,QAAd,EAAjB;AACA,SAAKF,cAAcG,WAAd,MAA+BZ,eAAe,IAA/C,IAAwD,CAACS,cAAcG,WAAd,EAA7D,EAA0F;AACzF;AACAZ,mBAAa,MAAKa,SAAL,CAAeJ,cAAcV,IAA7B,EAAmCU,cAAcZ,YAAjD,EAA+DY,cAAcH,IAA7E,CAAb;AACA;;AAED;AACA,SAAIG,cAAcG,WAAd,MAA+BH,cAAcE,QAAd,OAA8B,IAAjE,EAAuE;AACtEF,oBAAcE,QAAd,CAAuBX,UAAvB;AACA;;AAED;AACAH,kBAAaI,IAAb,CAAkBD,UAAlB;AACA,KAlBD;AAmBA;;AAED;AACA,OAAIM,KAAKC,MAAL,GAAc,CAAlB,EAAqBV,eAAeA,aAAaiB,MAAb,CAAoBR,IAApB,CAAf;;AAErB;AACA,6CAAWF,SAAX,mCAAwBP,YAAxB;AACA;;;;;;AAGF;;;QACSD,e,GAAAA,e","file":"injection-engine.class.js","sourcesContent":["/** import dependencies */\nimport { Dependency } from './dependency.class';\n\n/**\n * @class InjectionEngine\n * Binds dependecies for injection and constructs objects\n */\nclass InjectionEngine {\n\tconstructor() {\n\t\t/** @type {Dependency[]} An array of all dependencies that can be injected */\n\t\tthis.dependencies = [];\n\t}\n\n\t/**\n\t * Bind a new dependency for injection\n\t * @param {string} token The token id of the dependency\n\t * @param {object} item The object item itself that will be injected\n\t * @returns {Dependency} Returns the newly bound dependency\n\t */\n\tbind(token, item) {\n\t\t/** create a new dependency, add to array, and return */\n\t\tlet dependency = new Dependency(token, item);\n\t\tthis.dependencies.push(dependency);\n\t\treturn dependency;\n\t}\n\n\t/**\n\t * Get a dependency by the token name\n\t * @param {string} token The token id of the dependency\n\t * @returns {Dependency} Returns the dependency\n\t */\n\tget(token) {\n\t\treturn this.dependencies.find(d => d.token === token);\n\t}\n\n\t/**\n\t * Construct the given dependent class object with the give dependencies and arguments\n\t * @param {class} dependent The class that is depending on the dependencies\n\t * @param {string[]} tokens The token ids of all the dependencies\n\t * @param {object[]} args Additional arguments to pass to the constructor\n\t */\n\tconstruct(dependent, tokens = [], args = []) {\n\t\t/** recursively create dependencies */\n\t\tlet dependencies = [];\n\t\tif (tokens.length > 0) {\n\t\t\ttokens.forEach(token => {\n\t\t\t\t/** get the dependency */\n\t\t\t\tlet dependencyRef = this.get(token);\n\n\t\t\t\t/** check for singleton and instance */\n\t\t\t\tlet dependency = dependencyRef.instance();\n\t\t\t\tif ((dependencyRef.isSingleton() && dependency === null) || !dependencyRef.isSingleton()) {\n\t\t\t\t\t/** construct the dependency */\n\t\t\t\t\tdependency = this.construct(dependencyRef.item, dependencyRef.dependencies, dependencyRef.args);\n\t\t\t\t}\n\n\t\t\t\t/** set the dependencyRef instance */\n\t\t\t\tif (dependencyRef.isSingleton() && dependencyRef.instance() ===  null) {\n\t\t\t\t\tdependencyRef.instance(dependency);\n\t\t\t\t}\n\n\t\t\t\t/** add the dependency */\n\t\t\t\tdependencies.push(dependency);\n\t\t\t});\n\t\t}\n\n\t\t/** check for args */\n\t\tif (args.length > 0) dependencies = dependencies.concat(args);\n\n\t\t/** initialize the new dependent */\n\t\treturn new dependent(...dependencies);\n\t}\n}\n\n/** export InjectionEngine */\nexport { InjectionEngine };"]}